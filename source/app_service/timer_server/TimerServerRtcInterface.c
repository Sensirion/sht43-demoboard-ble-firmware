////////////////////////////////////////////////////////////////////////////////
//  S E N S I R I O N   AG,  Laubisruetistr. 50, CH-8712 Staefa, Switzerland
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2023, Sensirion AG
// All rights reserved.
// The content of this code is confidential. Redistribution and use in source
// and binary forms, with or without modification, are not permitted.
//
// THIS CODE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
// USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
////////////////////////////////////////////////////////////////////////////////

/// @file TimerServerRtcInterface.c
///
/// Implementation of all rescheduling events required for the timerserver.

#include "TimerServerRtcInterface.h"

#include "TimerServer.h"

#include <stdbool.h>

/// Maximal RTC interrupt delay
///
/// This value shall reflect the maximum delay there could be in the application
/// between the time the RTC interrupt is generated by the Hardware and the
/// time when the  RTC interrupt handler is called. This time is measured in
/// number of RTCCLK ticks.
/// A relaxed timing would be 10ms
#define RTC_HANDLER_MAX_DELAY (10 * (LSE_VALUE / 1000))

/// Read the RTC_SSR value
///
/// The SSR (subsecond register) stores the time passed that is smaller than
/// 1 second, as opposing the RTC_TR (time register), that returns the time
/// passed above seconds, and below days.
/// As described in the reference manual, the RTC_SSR shall be read twice to
/// ensure reliability of the value
/// @retval SSR value read
uint32_t ReadRtcSsrValue(void);

/// Set the wakeup counter
///
/// The API is writing the counter value to the RTC interrupt so that the value
/// is decreased by one to cope with the fact the interrupt is generated with 1
/// extra clock cycle(see RefManuel). It assumes all condition are met to be
/// allowed to write the wakeup counter
/// @param  value: Value to be written in the counter
static void RestartWakeupCounter(uint16_t value);

/// Determine how many ticks are left to be count until wakeup
///
/// Calculated the ticks left in the counter and if the number of ticks left
/// is bigger than the maximal wakeup timer value, as defined with
/// RTC_HANDLER_MAX_DELAY
/// @param timeCountLeft Timer ticks left to be counted
/// @param timeElapsed Timer elapsed since last check
/// @return Value when the times must wakes up next time
static uint16_t CalculateWakeupCounterValue(uint32_t timeCountLeft,
                                            uint16_t timeElapsed);

/// Read RTC user config
static void ReadRtcUserConfig(void);

/// Calculate the Maximal Wakeup Timer Ticks
static void CalculateMaxWakeupTimerSetup();

/// Check whether the wakeup timer is enabled
///
/// Check the Enable Bit of the Wakeup timer. If the WakeupTimer is disabled,
/// the Timer is disabled consequently, since the
/// TimerServerHelper_RescheduleTimerList() routine is skipped.
///
/// @return bool variable to determine whether the WakeupTimer is disabled
static bool IsTimerEnabled(void);

/// Global RTC_HandleTypeDef from System.c
static RTC_HandleTypeDef* gRtc;
/// Pointer to gTimerContext from TimerServer.c
static volatile TimerServerHelper_TimerContext_t* gTimerContext;
/// Pointer to gCurrentRunningTimerId from TimerServer.c
static volatile uint8_t* gCurrentRunningTimerId;
/// Variable storing the RTC_SSR (sub-second register) of the last setup
static volatile uint32_t gSsrValueOnLastSetup;
/// Divider to adjust the right wakeup time
static uint8_t gWakeupTimerDivider;
/// Asynchronous prescaler of the TimerServer
static uint8_t gAsynchPrescalerUserConfig;
/// Synchronous prescaler of the TimerServer
static uint16_t gSynchPrescalerUserConfig;
/// Variable to help to re-schedule the timer list
static volatile uint16_t gMaxWakeupTimerSetup;
/// Flag to assure the correct runtime state of the timer
static volatile TimerServerRtcInterface_WakeupTimerLimitationStatus_t
    gWakeupTimerLimitation;

void TimerServerRtcInterface_Init(
    RTC_HandleTypeDef* rtc,
    volatile TimerServerHelper_TimerContext_t* timerContext,
    volatile uint8_t* currentRunningTimerId) {
  gSsrValueOnLastSetup = 0xFFFFFFFF;

  ReadRtcUserConfig();
  CalculateMaxWakeupTimerSetup();

  gRtc = rtc;
  gTimerContext = timerContext;
  gCurrentRunningTimerId = currentRunningTimerId;
}

void TimerServerRtcInterface_SetSsrValueOnLastSetup(
    uint32_t ssrValueOnLastSetup) {
  gSsrValueOnLastSetup = ssrValueOnLastSetup;
}

TimerServerRtcInterface_WakeupTimerLimitationStatus_t
TimerServerRtcInterface_GetWakeupTimerLimitation() {
  return gWakeupTimerLimitation;
}

uint16_t TimerServerRtcInterface_ReturnTimeElapsed(void) {
  uint32_t returnValue;
  uint32_t wrapCounter;

  if (gSsrValueOnLastSetup != SSR_FORBIDDEN_VALUE) {
    // Read SSR register first
    returnValue = ReadRtcSsrValue();

    if (gSsrValueOnLastSetup >= returnValue) {
      returnValue = gSsrValueOnLastSetup - returnValue;
    } else {
      wrapCounter = gSynchPrescalerUserConfig - returnValue;
      returnValue = gSsrValueOnLastSetup + wrapCounter;
    }

    // At this stage, ReturnValue holds the number of ticks counted by SSR
    // Need to translate in number of ticks counted by the Wakeuptimer
    returnValue = returnValue * gAsynchPrescalerUserConfig;
    returnValue = returnValue >> gWakeupTimerDivider;
  } else {
    returnValue = 0;
  }

  return (uint16_t)returnValue;
}

void TimerServerRtcInterface_RescheduleTimerList(void) {
  uint8_t localTimerId;
  uint32_t timeCountLeft;
  uint16_t wakeupTimerValue;
  uint16_t timeElapsed;

  // The wakeuptimer is disabled now to reduce the time to poll the WUTWF
  // FLAG when the new value will have to be written
  if (IsTimerEnabled()) {
    // Wait for the flag to be back to 0 when the wakeup timer is enabled
    while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(gRtc, RTC_FLAG_WUTWF) == SET) {
    }
  }
  //  Disable the Wakeup Timer
  __HAL_RTC_WAKEUPTIMER_DISABLE(gRtc);

  localTimerId = *gCurrentRunningTimerId;

  // Calculate what will be the value to write in the wakeuptimer
  timeCountLeft = (gTimerContext + localTimerId)->countLeft;

  // Read how much has been counted
  timeElapsed = TimerServerRtcInterface_ReturnTimeElapsed();

  wakeupTimerValue = CalculateWakeupCounterValue(timeCountLeft, timeElapsed);

  // update ticks left to be counted for each timer
  while (localTimerId != MAX_NBR_CONCURRENT_TIMER) {
    if ((gTimerContext + localTimerId)->countLeft < timeElapsed) {
      (gTimerContext + localTimerId)->countLeft = 0;
    } else {
      (gTimerContext + localTimerId)->countLeft -= timeElapsed;
    }
    localTimerId = (gTimerContext + localTimerId)->nextId;
  }

  // Write next count
  RestartWakeupCounter(wakeupTimerValue);
}

uint32_t ReadRtcSsrValue(void) {
  uint32_t firstRead;
  uint32_t secondRead;

  firstRead = (uint32_t)(READ_BIT(RTC->SSR, RTC_SSR_SS));

  secondRead = (uint32_t)(READ_BIT(RTC->SSR, RTC_SSR_SS));

  while (firstRead != secondRead) {
    firstRead = secondRead;

    secondRead = (uint32_t)(READ_BIT(RTC->SSR, RTC_SSR_SS));
  }

  return secondRead;
}

static void RestartWakeupCounter(uint16_t value) {
  // The wakeuptimer has been disabled in the calling function to reduce the
  // time to poll the WUTWF FLAG when the new value will have to be written
  if (value == 0) {
    gSsrValueOnLastSetup = ReadRtcSsrValue();

    // Simulate that the Timer expired
    HAL_NVIC_SetPendingIRQ(RTC_WKUP_IRQn);
  } else {
    if ((value > 1) || (gWakeupTimerDivider != 1)) {
      value -= 1;
    }

    while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(gRtc, RTC_FLAG_WUTWF) == RESET) {
    }

    // make sure to clear the flags after checking the WUTWF.
    // It takes 2 RTCCLK between the time the WUTE bit is disabled and the
    // time the timer is disabled. The WUTWF bit somehow guarantee the system is
    // stable. Otherwise, when the timer is periodic with 1 Tick, it may
    // generate an extra interrupt in between due to the autoreload feature

    //  Clear flag in RTC module
    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(gRtc, RTC_FLAG_WUTF);
    //  Clear flag in EXTI module
    __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
    // Clear pending bit in NVIC
    HAL_NVIC_ClearPendingIRQ(RTC_WKUP_IRQn);

    MODIFY_REG(RTC->WUTR, RTC_WUTR_WUT, value);

    // Update the value here after the WUTWF polling that may take some time
    gSsrValueOnLastSetup = ReadRtcSsrValue();

    // Enable the Wakeup Timer
    __HAL_RTC_WAKEUPTIMER_ENABLE(gRtc);
  }
}

static uint16_t CalculateWakeupCounterValue(uint32_t timeCountLeft,
                                            uint16_t timeElapsed) {
  uint16_t wakeupCounterValue;
  if (timeCountLeft < timeElapsed) {
    // There is no tick left to count
    gWakeupTimerLimitation = WAKEUP_TIMER_VALUE_LARGE_ENOUGH;

    wakeupCounterValue = 0;
  } else {
    if (timeCountLeft > (timeElapsed + gMaxWakeupTimerSetup)) {
      // The number of tick left is greater than the Wakeuptimer maximum value
      gWakeupTimerLimitation = WAKEUP_TIMER_VALUE_OVERPASSED;

      wakeupCounterValue = gMaxWakeupTimerSetup;
    } else {
      gWakeupTimerLimitation = WAKEUP_TIMER_VALUE_LARGE_ENOUGH;

      wakeupCounterValue = (timeCountLeft - timeElapsed);
    }
  }
  return wakeupCounterValue;
}

static void CalculateMaxWakeupTimerSetup() {
  uint32_t maxWakeupTimerSetup;
  // Margin is taken to avoid wrong calculation when the wrap around is there
  // and some application interrupts may have delayed the reading
  maxWakeupTimerSetup =
      ((((gSynchPrescalerUserConfig - 1) * gAsynchPrescalerUserConfig) -
        RTC_HANDLER_MAX_DELAY) >>
       gWakeupTimerDivider);

  if (maxWakeupTimerSetup >= 0xFFFF) {
    gMaxWakeupTimerSetup = 0xFFFF;
  } else {
    gMaxWakeupTimerSetup = (uint16_t)maxWakeupTimerSetup;
  }
}

static void ReadRtcUserConfig(void) {
  // Set the bypass shadow bit
  //
  // When the bypass shadow bit is set, the need to wait for the RSF bit is
  // eliminated. I.e. the calendar values from the calendar are given directly
  SET_BIT(RTC->CR, RTC_CR_BYPSHAD);

  // RTC_CR_WUCKSEL register:
  // 000: RTC/16 clock is selected
  // 001: RTC/8 clock is selected
  // 010: RTC/4 clock is selected
  // 011: RTC/2 clock is selected
  // 10x: ck_spre (usually 1 Hz) clock is selected
  // 11x: ck_spre (usually 1 Hz) clk is sel. and 216 is added to the WUT cnt val
  // (4 - WUCKSEL) is used due to a bitshift representing the prescaler
  gWakeupTimerDivider = (4 - ((uint32_t)(READ_BIT(RTC->CR, RTC_CR_WUCKSEL))));

  // Read the Asynchronous Prescaler Config:
  // PREDIV_A Bit Pos: 16- 22
  // ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
  gAsynchPrescalerUserConfig =
      (uint8_t)(READ_BIT(RTC->PRER, RTC_PRER_PREDIV_A) >>
                (uint32_t)POSITION_VAL(RTC_PRER_PREDIV_A)) +
      1;
  // Read the Synchronous Prescaler Config:
  // PREDIV_A Bit Pos: 0-15
  // ck_spre frequency = ck_apre frequency/(PREDIV_S+1)
  gSynchPrescalerUserConfig =
      (uint16_t)(READ_BIT(RTC->PRER, RTC_PRER_PREDIV_S)) + 1;
}

static bool IsTimerEnabled(void) {
  return (READ_BIT(RTC->CR, RTC_CR_WUTE) == RTC_CR_WUTE);
}

/// Interrupt routine for the TimerServer
void RTC_WKUP_IRQHandler(void) {
  TimerServer_RtcWakeupHandler();
}
